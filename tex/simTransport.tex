%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RAPPORT DE CEI // TNP CONSULTANTS // ETP ADVISOR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper, 11pt]{article} % Font size (can be 10pt, 11pt or 12pt) and paper size (remove a4paper for US letter paper)

\renewcommand{\contentsname}{Table des matières}
\renewcommand{\listfigurename}{Table des figures}

\usepackage{hyperref}

\usepackage[babel=true]{csquotes}

\usepackage{standalone}

\usepackage{changepage}

\usepackage{caption}
\usepackage{subcaption}

%\usepackage[a4paper,left=2.5cm,right=2.5cm]{geometry}

\addtolength{\hoffset}{-1cm}
\addtolength{\textwidth}{2cm}
\addtolength{\topmargin}{-1.5cm}
\addtolength{\textheight}{2cm}

\usepackage{indentfirst}
%\usepackage[utf8]{inputenc}
\usepackage{pgfplots}
\usepackage{color}

\usepackage{enumerate}

\usepackage[protrusion=true,expansion=true]{microtype} % Better typography

\renewcommand{\thesection}{\Roman{section}}
\usepackage{titlesec}
%\titlespacing\section{0pt}{20pt plus 4pt minus 2pt}{-5pt plus 2pt minus 2pt}

\usepackage{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Required for accented characters
\linespread{1.05} % Change line spacing here, Palatino benefits from a slight increase by default

\makeatletter
\renewcommand\@biblabel[1]{\textbf{#1.}} % Change the square brackets for each bibliography item from '[1]' to '1.'
\renewcommand{\@listI}{\itemsep=0pt} % Reduce the space between items in the itemize and enumerate environments and the bibliography

\usepackage{titlesec}
\usepackage[T1]{fontenc}
%\titlespacing{\chapter}{0}{0*}{0*}{}
%\titlespacing{\section}{2ex}{0*}{0*}{}
\usepackage{colortbl}
\usepackage{multirow}

%\newdimen\saveskip % Un registre pour garder la valeur actuelle de \leftskip
\newdimen\chapterskip
\newdimen\sectskip
\newdimen\subsectskip
\newdimen\subsubsectskip

%\saveskip=\leftskip
\chapterskip=10pt     % Espacement pour les chapitres
\sectskip=4ex        % Pour les sections
\subsectskip=10ex    % etc.
\subsubsectskip=18ex

% Reprise de ton code ici, mais en appelant les valeurs définies plus haut

\setcounter{secnumdepth}{3} % On affiche une numérotation sur une profondeur de 3
%\setcounter{tocdepth}{3} % La table des matières va a une profondeur de 3
% Alignement des titres :
%\titlespacing{\chapter} {\chapterskip} {*0} {*0} {}
%\titlespacing{\section} {\sectskip} {*0} {*0} {}
%\titlespacing{\subsection} {\subsectskip} {*0} {*0} {}
%\titlespacing{\subsubsection} {\subsubsectskip} {*0} {*0} {}

% Et ici, on surcharge les commandes \chapter, \section, etc.,
% afin de modifier \leftskip.

\setcounter{tocdepth}{3}

\renewcommand{\thesection}{\Roman{section}}

\titleformat{\paragraph}[hang]{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}{0pt}{3.25ex plus 1ex minus .2ex}{1em}

%----------------------------------------------------------------------------------------
%	FIGURES ET IMAGES
%----------------------------------------------------------------------------------------

\usepackage{graphicx} % Required for including pictures
\usepackage{wrapfig} % Allows in-line images

\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage{pgf}
\usepackage{pgfplots}
\usetikzlibrary{arrows}
\usepackage{tkz-graph}
\usetikzlibrary{shapes.multipart}

%----------------------------------------------------------------------------------------
%	TITLE
%----------------------------------------------------------------------------------------

\renewcommand{\maketitle}{ % Customize the title - do not edit title and author name here, see the TITLE block below
\begin{flushright} % Right align
{\LARGE\@title} % Increase the font size of the title

\vspace{50pt} % Some vertical space between the title and author name

{\large\@author} % Author name
\\\@date % Date

\vspace{-20pt} % Some vertical space between the author block and abstract
\end{flushright}
}

%-----------

\title{\textbf{Introduction aux Systèmes Multi-Agents}\\ % Title
Projet : SimTransport} % Subtitle

\author{\textsc{Fran\c cois Hernandez - L\'eo Pons} % Author
\\{\textit{CentraleSup\'elec}}} % Institution

\date{\today} % Date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title section

\pagebreak
\tableofcontents

\pagebreak

%----------------------------------------------------------------------------------------
%	ABSTRACT AND KEYWORDS
%----------------------------------------------------------------------------------------

%\renewcommand{\abstractname}{Summary} % Uncomment to change the name of the abstract to something else



\vspace{30pt} % Some vertical space between the abstract and first section

%----------------------------------------------------------------------------------------
%	ESSAY BODY
%----------------------------------------------------------------------------------------

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

Un Système Multi-Agents est un système composé d'un ensemble d'agents, situés dans un certain environnement et interagissant selon certaines relations. Un agent est une entité caractérisée par le fait qu'elle est, au moins partiellement, autonome. Le fonctionnement du système est défini par le fonctionnement des agents, le système central ne fait qu'office d'environnement d'évolution et de communication des différents agents. On parle d'intelligence artificielle distribuée.\\

Ce projet a pour objectif de construire une simulation des transports sur le plateau de Saclay. Pour cela, on utilisera la plateforme Jade. La plateforme Jade est une plateforme répartie d'agents s'exécutant de manière asynchrone (chaque agent est une thread). Chaque agent définit ses actions à l'aide de comportements qu'il exécute les uns après les autres. La programmation de ces comportements se fait de manière à les "entrelacer' dans l'exécution de l'agent. Dans ces comportements, les agents peuvent envoyer et recevoir des messages, mais ils peuvent aussi déclencher d'autre comportements ou même créer d'autres agents.\\

Le but du projet est de simuler et d'étudier des politiques d'aménagement des transports à l'aide d'un simulateur multi-agent. Nous adoptons une modélisation simplifiée pour étudier quelques hypothèses et mesurer l'impact des paramètres sur la simulation.\\

Ce rapport fait le tour de notre travail mais ne va pas forcément au coeur des implémentations, celles-ci étant commentées à même le code.


%------------------------------------------------
\pagebreak
\section{Présentation générale}

Nous avons donc construit un prototype de plateforme pour simuler les déplacements des utilisateurs sur le plateau de Saclay. Cette simulation n'est pas une fin en soi, l'idée est de pouvoir simuler et donc tenter prédire le comportement de ces utilisateurs (par exemple leur propension à choisir les transports en commun) en fonction de différents paramètres (par exemple la fréquence des transports en commun, ou la fermeture d'une route). L'application doit donc pouvoir être utilisée pour estimer l'impact de paramètres réels sur le traffic.

\subsection{Fonctionnement général}

Le prototype comprend un simulateur des déplacements d'agents sur le plateau sur une journée. Les agents qui évoluent au cours de cette journée sont déterminés à l'avance, et ont un emploi du temps à suivre et un choix de mode de transport fixé : soit la voiture, soit les transports en commun et la marche. Au cours de la journée, des embouteillages peuvent se créer pour les voyageurs en voiture s'ils sont trop nombreux, ce qui les ralentit considérablement. Les performances des deux modes de transport (temps passé à voyager) sont relevées pendant toute la journée.\\

À partir de ce simulateur sont possibles deux types de déductions :
\begin{itemize}
\item Des estimations de performances du réseau : avec un pool d'utilisateurs donné, simplement mesurer les performances du réseau, et évaluer la criticité du blocage de certaines routes ou de la suppression de certaines lignes de bus.
\item Des estimations du comportement des utilisateurs : la simulation peut être effectuée sur plusieurs jours. Les agents sont les mêmes de jour en jour, mais choisissent chaque matin d'utiliser la voiture ou les transports en commun en fonction des performances des jours précédents. On peut ainsi étudier l'impact d'un changement dans le réseau sur plusieurs jours et donc l'évolution des choix des utilisateurs.
\end{itemize}


\subsection{Structure globale du code}
 
Le programme comporte les packages suivants :
\begin{itemize}
\item \texttt{Environment} : contient les différents éléments de l'environnement dans lequel se déroulera la simulation (horloge et environnement) ;
\item \texttt{Environment.Points} : contient les différents types de points ;
\item \texttt{Environment.Paths} : contient les différents types de chemins ;
\item \texttt{Graphics} : contient les différentes classes associées à la représentation graphique de la simulation ;
\item \texttt{Individuals} : contient les différentes classes et comportements liés aux individus.
\item \texttt{Util} : contient la classe permettant d'importer les points et chemins stockés au format \texttt{csv} ;
\item \texttt{mainPackage} : contient la classe agent \texttt{Starter} et son comportement \texttt{Days} qui permettent de créer l'environnement et les agents pour lancer la simulation.
\end{itemize}

%------------------------------------------------
\pagebreak
\section{Objets et structure du programme}

Avant même de considérer la partie simulation multi-agents, il faut créer la structure du programme permettant de simuler le problème. La structure choisie est détaillée ci-après.

\subsection{Points}

Afin de représenter les différents points utiles à notre simulation, nous créons les classes suivantes, regroupées dans le package \texttt{Environment.Points} :
\begin{itemize}
\item \texttt{Point} : point "classique" ne représentant pas de lieu particulier, comporte des coordonnées (\texttt{x}, \texttt{y}, \texttt{z}), un \texttt{id} entier et un nom \texttt{name} ainsi que les différents getters et setters utiles ;
\item \texttt{EntryPoint} : point "source" à partir duquel les individus entreront dans la simulation, hérite de \texttt{Point} ;
\item \texttt{InterestPoint} : point "d'intérêt" auquel les individus désireront se rendre, hérite de \texttt{Point} ;
\item \texttt{PreEntryPoint} : point se trouvant avant les points d'entrée, afin d'éviter toute situation où un agent d'un certain type serait bloqué à un \texttt{EntryPoint} ne disposant pas de chemin compatible avec son type.
\end{itemize}

\subsection{Chemins}

Nous représentons aussi différents types de chemins. Pour cela, nous avons fait le choix d'un typage fort des chemins. Nous aurons un objet par type de chemin et par sens (de A vers B). Ainsi, par exemple, pour un chemin qui peut être emprunté par des piétons et des vélos, dans les deux sens, il y aura quatre objets. Les classes sont donc définies de la manière suivante dans le package \texttt{Environment.Paths} :
\begin{itemize}
\item \texttt{Path} : classe mère dont hériteront tous les chemins 'typés', comporte un point \texttt{A} source et un point \texttt{B} destination, les getters et setters associés ainsi que différentes méthodes permettant de récupérer la distance (dans l'espace et projetée sur le plan), le dénivelé et la pente ;
\item \texttt{FootPath} : chemin piéton héritant de \texttt{Path} et comportant une méthode \texttt{weight()} retournant le temps de parcours nécessaire (pour une vitesse moyenne de 5km/h, et prenant en compte la difficulté accrue pour un dénivelé positif) ;
\item \texttt{RoadPath} : chemin routier (agglomération) héritant de \texttt{Path} et comportant une méthode \texttt{weight()} retournant le temps de parcours nécessaire pour une vitesse moyenne de base de 35 km/h, la durée étant exponentiellement allongée lorsque la densité d'utilisateurs sur la voie dépasse un seuil critique de 1 utilisateur pour 10m (embouteillages) ;
\item \texttt{HighwayPath} : chemin routier (nationale) héritant de \texttt{Path} et comportant une méthode \texttt{weight()} retournant le temps de parcours nécessaire pour une vitesse moyenne de base de 90 km/h, la durée étant exponentiellement allongée lorsque la densité d'utilisateurs sur la voie dépasse un seuil critique de 2 utilisateurs pour 10m (embouteillages) ;
\item \texttt{BusPath} : chemin représentant un autobus (de vitesse moyenne 50 km/h), héritant de \texttt{Path} et comportant un temps d'attente moyen et une méthode \texttt{weight()} retournant le temps de parcours nécessaire (calculé à partir de la vitesse et du temps perdu aux arrêts) ;
\item \texttt{RerPath} : chemin représentant un RER (de vitesse moyenne 80 km/h), héritant de \texttt{Path} et comportant un temps d'attente moyen et une méthode \texttt{weight()} retournant le temps de parcours nécessaire (calculé à partir de la vitesse et du temps perdu aux arrêts) ;
\item \texttt{EntryPath} : chemin entre les \texttt{PreEntryPoint} et \texttt{EntryPoint}, de poids nul (un agent débutera, sans délai, au point d'entrée le plus proche correspondant à son type).
\end{itemize}

\subsection{Temps}

Nous avons aussi créé une classe \texttt{Time} afin de représenter le temps et de pouvoir implémenter une horloge pour notre problème. Cette classe comporte trois attributs byte \texttt{hours}, \texttt{minutes} et \texttt{seconds}, ainsi que leurs getters. Elle comporte aussi les méthodes suivantes :
\begin{itemize}
\item \texttt{incMinute(byte m)} : incrémente l'heure de \texttt{m} minutes ;
\item \texttt{incSeconds(byte s)} : incrémente l'heure de \texttt{s} secondes ;
\item \texttt{equals(Time toCompare)} : retourne un booléen vrai si \texttt{this} et \texttt{toCompare} sont égaux ;
\item \texttt{randomBegin()} : retourne une heure aléatoire de départ du point d'entrée, distribuée selon une gaussienne autour de 10h du matin, entre 2h et 20h, et les minutes sont déterminées aléatoirement ;
\item \texttt{randomEnd(Time begin)} : retourne une heure aléatoire de départ du travail, distribuée selon une gaussienne autour de 18h, comprise entre l'heure d'arrivée plus deux heures et minuit, et les minutes sont déterminées aléatoirement.
\end{itemize}

\subsection{Environnement}

Afin de représenter l'environnement global de notre simulation, nous avons créé une classe \texttt{Environment} qui sera instanciée une unique fois et contiendra les différents éléments du problème.

\subsubsection{Attributs}

Cette classe contient les différents éléments de la simulation :
\begin{itemize}
\item \texttt{points} : une \texttt{ArrayList} d'objets \texttt{Point} (classe mère et sous-classes) comprenant l'ensemble des points considérés ;
\item \texttt{carPaths} : une \texttt{ArrayList} d'objets \texttt{Path} n'autorisant que les usagers en voiture (\texttt{RoadPath} et \texttt{HighwayPath}) ;
\item \texttt{publicTransportPaths} : une \texttt{ArrayList} d'objets \texttt{Path} n'autorisant que les usagers non motorisés (\texttt{FootPath}, \texttt{BikePath}, \texttt{BusPath} et \texttt{RerPath}).
\end{itemize}

\subsubsection{Méthodes}

En plus des getters et setters usuels, cette classe contient également les méthodes permettant d'implémenter un algorithme de Djikstra afin de retourner le plus court chemin d'un point A à un point B sur le graphe des points de l'environnement.
\begin{itemize}
\item \texttt{initializeWeights} : à partir d'une \texttt{ArrayList<Point>} et d'une \texttt{ArrayList<Path>}, retourne la matrice des poids minimal entre les points, c'est à dire la matrice de taille \texttt{n}x\texttt{n} avec \texttt{n} le nombre de points, contenant l'éventuel poids minimal (s'il existe un chemin) entre deux points ;
\item \texttt{initializePaths} : à partir d'une \texttt{ArrayList<Point>}, d'une \texttt{ArrayList<Path>} et d'une matrice de poids (\texttt{double[][]}, retourne la matrice des éventuels chemins de poids minimal entre les points ;
\item \texttt{shortestPathPointList} : implémente, à partir d'une \texttt{ArrayList<Point>}, d'une \texttt{ArrayList<Path>}, d'un point \texttt{source} et d'un point \texttt{target}, l'algorithme de Djikstra et retourne une \texttt{ArrayList<Point>} contenant les points formant le plus court chemin entre deux points ;
\item \texttt{shortestPath} : récupère la liste des chemins formant le plus court chemin, à partir des méthodes \texttt{findShortestPath} et \texttt{initializePaths} ;
\item \texttt{shortestCarPath} : retourne les chemins formant le plus court chemin pour un usager automobiliste ;
\item \texttt{shortestPublicTransportPath} : retourne les chemins formant le plus court chemin pour un usager non motorisé.
\end{itemize}

\subsection{Import}

La classe \texttt{Import} du package \texttt{Util} permet d'importer les points et chemins depuis des fichiers \texttt{csv}, afin de faciliter l'ajout de nouveaux éléments et la création des différents objets dans le programme.\\

Cette classe constitue un objet qui sera instancié en début de simulation, et qui contient en attributs les différentes listes d'objets (points et chemins) qui constitueront l'environnement. Cette classe contient une méthode pour chaque type d'objet, qui parcourt et parse chaque fichier \texttt{csv} (un par type d'objet), appelle le constructeur associé sur chaque instance, et l'ajoute à l'\texttt{ArrayList} attribut correspondant. Les fichiers \texttt{csv} sont stockés dans le dossier \texttt{objects}.\\

Au début de la simulation, il suffit d'instancier un objet de la classe \texttt{Import} à l'aide de son constructeur, qui appelle dans l'ordre défini les différentes méthodes d'importation des objets, et ensuite de récupérer les différentes listes dont on aura l'utilité à l'aide des getters associés.\\

\pagebreak

\section{Agents et comportements}

\subsection{Horloge}

Dans le package \texttt{Environment} on retrouve deux classes : \texttt{Clock} et \texttt{ClockTick}. Notre premier agent, le plus important, est en effet l'horloge. Un seul agent d'horloge est créé pour la journée, et sont rôle sera de mesurer l'heure et d'en informer les autres agents.\\

\texttt{Clock} possède un attribut \texttt{currentTime} de type \texttt{Time} décrit plus haut. Cet attribut représente l'heure de notre système. Elle est régulièrement incrémentée à l'aide du comportement \texttt{ClockTick} héritant de \texttt{TickerBehaviour} de Jade. Ce type de comportement est appelé à intervalles réguliers, l'intervalle étant défini ici à l'aide de la durée réelle \texttt{simulationTime} d'exécution souhaitée pour une journée simulée ; et de l'intervalle de temps minimal simulé \texttt{stepLength}, typiquement 15 secondes (un intervalle plus grand, de une minute par exemple, a l'inconvénient d'arrondir à une minute toutes les durées inférieures, ce qui fausse vite la simulation sur les segments courts).\\

À chaque tick d'horloge, \texttt{ClockTick} envoie aussi un message contenant l'heure du système à tous les autres agents. Le comportement s'arrête quand minuit est atteint. Un message est alors envoyé à l'agent \texttt{Starter} pour prévenir de la fin de journée.\\

\subsection{Individus}

\subsubsection{Principaux attributs}

Chaque personne est représentée par un agent \texttt{Person}. Ils possèdent chacun des attributs comme :
\begin{itemize}
\item Leur point de pré-entrée, déterminé à la construction
\item Leur emploi du temps \texttt{schedule}, déterminé à la construction et qui sera "consommé" au fur et à mesure de la journée
\item Leur localisation (point et éventuellement chemin)
\item Leur choix de mode de transport, déterminé à la construction
\item L'ID de la ligne de transport en commun qu'ils empruntent actuellement (0 sinon). Cela servira pour détecter les changements de ligne.
\end{itemize}

L'emploi du temps \texttt{schedule} consiste en une liste de rendez-vous \texttt{Appointement}, qui sont eux-mêmes de simples couples (\texttt{Point}, \texttt{Time}) correspondants à la destination et à l'heure de départ (et non d'arrivée).\\

Ces agents fonctionnent comme des machines à état, et un type énuméré \texttt{PersonState} est donc créé pour décrire ces états. Trois états sont possibles : 
\begin{itemize}
\item \texttt{in\_place} : La personne est là où elle doit se trouver, mais il reste des déplacements prévus dans son emploi du temps.
\item \texttt{moving} : La personne est en déplacement.
\item \texttt{gone} : La personne est rentrée chez elle, son emploi du temps a été entièrement exécuté, elle n'interviendra plus de la journée.
\end{itemize}

Cet état est stocké dans l'attribut \texttt{personState}. Les comportements \texttt{InPlace} et \texttt{Moving} associés sont décrits dans les parties suivantes (L'état \texttt{gone} n'a pas de comportement associé : cet état correspond à l'arrêt des différents comportements).

\subsubsection{Comportement InPlace}

Quand il est \texttt{in\_place}, l'agent attend un signal de départ à l'aide de son comportement \texttt{InPlace}. C'est un comportement déclenché à chaque réception de tick d'horloge. L'heure est comparée avec l'heure du départ du prochain \texttt{Appointement}. Si il est l'heure de partir, on enclenche le trajet en créant un nouveau comportement \texttt{Moving} associé au point de destination. Le rendez-vous est supprimé du \texttt{schedule}, \texttt{PersonState} est modifié, et le comportement \texttt{InPlace} est ensuite arrêté. \\

\subsubsection{Comportement Moving}

Quand il est \texttt{moving}, l'agent se déplace vers son point de destination à l'aide de son comportement \texttt{Moving}. Le comportement est créé avec un point de destination, conservé en attribut. Lors de son déplacement, l'agent peut se trouver dans deux états différents correspondant à des phases différentes du mouvement. On créera pour celà un type énuméré \texttt{MovingState} :
\begin{itemize}
\item \texttt{none} : La personne n'est pas dans un état de mouvement \texttt{moving}
\item \texttt{point} : La personne est à un \texttt{Point}, en attente du choix du prochain \texttt{Path}
\item \texttt{path} : La personne est en train de parcourir un \texttt{Path}
\end{itemize}

Quand il est sur un point, l'agent récupère le prochain segment à emprunter à l'aide de Djikstra. On récupère le temps nécessaire pour parcourir le segment (prenant en compte comme expliqué la côte à pied, les embouteillages en voiture, et le temps d'arrêt en transports en commun). On y ajoute l'éventuel temps d'attente moyen lors d'un changement de ligne. On stocke ce temps dans un attribut \texttt{timeNeeded} et on initialise un compteur de temps passé sur le segment \texttt{currentPathProgress} à 0. On incrémente les compteurs globaux de temps passé dans les transports. Le moving state est finalement passé à \texttt{path}.\\

Quand il est sur un segment, l'agent écoute les tick d'horloge et incrémente son compteur de temps passé sur le segment \texttt{currentPathProgress}. Quand \texttt{timeNeeded} est atteint, on change finalement l'attribut \texttt{localisation} de l'agent pour le placer sur le prochain point. Si le point atteint est la destination, on arrête le mouvement et on passe en \texttt{in\_place} si il reste des rendez-vous et en \texttt{gone} sinon. Si le point atteint n'est pas la destination, le mouvement continue et on recommence ce cycle en passant le moving state à \texttt{point}.\\

\subsubsection{Construction}

Les personnes présentent un constructeur qui permet de les construire à la main, mais nous utiliserons plutôt un constructeur \texttt{rand\_AllerRetour} qui construit une personne avec un emploi du temps simple : un aller retour depuis un point de pré-entrée vers un point d'intérêt. Les heures des trajets sont définies à l'aide de \texttt{randomBegin()} et \texttt{randomEnd()} décrite plus haut dans la section Time.\\

On se rendra vite compte que la création de trop nombreux agents peut créer des problèmes de mémoire et de CPU suivant la machine et les paramètres. Pour pouvoir constater des embouteillages plus facilement, on introduira dans le starter un paramètre \texttt{realUsersPerPerson} qui représente le nombre d'usagers réels représentés par un agent \texttt{Person}. Cette valeur interviendra dans les calculs de densité d'utilisateurs des routes.\\

\pagebreak 
\section{Interface graphique}

Afin d'avoir une représentation graphique claire des différents points, chemins, et des évènements de la simulation, nous avons choisi de définir une interface graphique à l'aide des outils \texttt{Swing}. Cela consiste en deux classes \texttt{Window} et \texttt{Panel}. \texttt{Window} hérite de la classe \texttt{JFrame} et définit les caractéristiques de la fenêtre qui contiendra le \texttt{Panel}. \texttt{Panel} hérite de la classe \texttt{JPanel} et contient les méthodes associées au dessin des représentations. La méthode \texttt{paintComponent} dessine les différents éléments dans un \texttt{bufferGraphics}, attribut d'une image. L'horloge est également affichée.\\

Afin d'avoir une simulation plus réaliste et de pouvoir mieux se représenter le problème, nous avons choisi de nous baser sur une carte réelle (Google Maps) pour définir nos points et chemins.\\

\begin{figure}[!h]
\begin{center}
\includegraphics[width=0.8\textwidth]{plateau.png}
\caption{Représentation graphique de la simulation}
\vspace{-0.5cm}
\end{center}
\end{figure}

Les différents éléments sont ajoutés au \texttt{bufferGraphics} dans la méthode \texttt{paintComponent} via les méthodes de dessin classique de \texttt{Swing}. Les points d'entrée sont représentés par des disques (\texttt{fillCirce}) roses, et les points d'intérêt sont représentés par des disques rouges et leur nom est affiché (\texttt{drawString}).\\

Les chemins de type route sont représentés en noir, et avec un trait plus épais pour les chemins de type nationale ou autoroute. Les chemins de type RER sont représentés en bleu légèrement plus épais. Les chemins piétons et cyclistes sont représentés en vert. Les chemins d'autobus sont représentés en bleu transparent légèrement plus large, afin d'apparaître sur les chemins routier. Enfin, pour les chemin de type \texttt{roadPath} et \texttt{highwayPath}, qui peuvent être saturés, nous avons fait le choix de représenter la saturation par une couleur (vert, orange ou rouge selon le niveau), ainsi qu'avec une épaisseur variable (en fonction du rapport entre le nombre d'agents et la capacité effective).\\

De plus, chaque agent (pouvant représenter plusieurs personnes), est représenté par un pictogramme de la forme d'un bonhomme. Ces pictogrammes se déplacent sur la carte (aux différents points de l'environnement) en suivant le déplacement de l'agent associé. Pour cela, la liste des agents \texttt{Persons} est ajoutée au constructeur du \texttt{Panel}, afin de pouvoir accéder aux informations des objets.\\

Un exemple de simulation avec des chemins saturés est présenté figure 2.

\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{saturation.png}
\caption{Simulation provoquant la saturation sur certaines routes}
\end{center}
\end{figure}



%------------------------------------------------
\pagebreak

\section{Utilisation et inflluence des paramètres}

\subsection{Lancement d'une simulation}

Le lancement d'une simulation se fait via le lancement d'un agent \texttt{Starter}. Pour cela le plus simple est de créer une nouvelle Run Configuration avec comme Main class \texttt{jade.Boot} et comme Program arguments :\\

\texttt{-local-host 127.0.0.1 -agents "starter:mainPackage.Starter"} \\

Les différents paramètres disponibles sont décrits dans la partie suivante.

\subsection{Paramètres d'affichage}

\subsubsection{Console}

Un paramètre \texttt{verbose} est présent dans le starter. Il décrit la quantité d'information affichée en console lors de la simulation. Différents niveaux de précision sont disponibles~:
\begin{itemize}
\item \texttt{verbose <= -1} : Rien n'est affiché
\item \texttt{verbose = 0} : Seulement le bilan des différentes journées est affiché
\item \texttt{verbose = 1} : Sont affichés le bilan des journées, les lancements des personnes, les départs et arrivées des différentes personnes, le témoin des imports
\item \texttt{verbose >= 2} : Sont en plus affichés le détail des trajets des personnes
\end{itemize}

\subsubsection{Interface graphique}

Un paramètre booléen \texttt{showSimulation} est disponible pour l'affichage de la simulation. Un paramètre boolean \texttt{showTraffic} est aussi disponible pour camoufler les bordures affichées représentant la densité d'utilisateurs. La taille de la fenêtre est aussi modifiable.\\

\subsection{Paramètres généraux de simulation}

Des paramètres généraux de simulation dont certains ont déjà été évoqués plus haut sont modifiables dans \texttt{Starter} : 
\begin{itemize}
\item \texttt{simulationTime} : durée réelle de la simulation d'une journée de 24 heures
\item \texttt{stepLength} : intervalle minimal de temps simulé (15 secondes recommandé)
\item \texttt{startHour} : heure de début de la simulation
\item \texttt{nbPersons} : nombre de personnes simulées
\item \texttt{realUsersPerPerson} : nombre d'utilisateurs réels représentés par un agent (pour l'encombrement des routes)
\end{itemize}

Les paramètres des lois gaussiennes des heures générées aléatoirement lors de la création des emplois du temps : \texttt{centerBeginTime, sigmaBeginTime, centerEndTime, sigmaEndTime}.

\subsection{Paramètres des Path}

Les paramètres des classes \texttt{Path} comme la vitesse moyenne, le seuil critique de densité pour les routes automobiles, ou le temps perdu à chaque arrêt pour les transports en commun, sont accessibles directement dans les classes concernées. Ce sont des paramètres qui concernent le système réel lui même, nous n'avons donc pas désiré les faire apparaître directement dans le starter avec les autres paramètres.\\

On peut aussi imaginer des \texttt{Path} qui auraient une certaine densité d'utilisateurs "de base", indépendante de notre système, comme sur la N118 par exemple (qui peut être embouteillée indépendamment des comportements des usagers du plateau de Saclay).\\

On peut ainsi vérifier le comportement du prototype et de ces paramètres en effectuant des simulations. Par exemple, on effectuera deux simulations, en changeant le temps d'arrêt et le temps moyen d'attente des transports communs. On vérifie en console les durées annoncées sur chaque trajet, et on trouve bien des différences de performances, reportées en figure 3.

\begin{center}
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{RER}  & \textbf{RER}  & \textbf{Bus}  & \textbf{Bus}   & \textbf{Aller-Retour moyen} \ \\
 stopTime &  waitingTime &  stopTime &  waitingTime & \textbf{en transports en commun} \\ \hline
15 & 3 & 20 & 5 & 3199 secondes \\ \hline
30 & 6 & 40 & 10 & 3711 secondes \\ \hline
\end{tabular}\\
\vspace{0.5cm}
Figure 3 : Différences de performances selon les paramètres des transports
\end{center}

\subsection{Paramètres du modèle de décision}

Comme précisé en première partie, au delà de vouloir mesurer les performances du système selon les conditions, les routes éventuellement fermées, les lignes de bus créées etc, il est aussi possible de modéliser le comportement des utilisateurs et leur choix de transport sur plusieurs jours.\\

Les paramètres concernant cet aspect du prototype sont disponibles dans \texttt{Starter}, juste en dessous des paramètres généraux. On trouve : 
\begin{itemize}
\item \texttt{totalDays} : le nombre de jours
\item \texttt{carFactorInit} : la probabilité initiale qu'une personne choisisse la voiture face aux transports en commun
\item \texttt{carFactor()} : dans cette fonction réside le modèle de décision des agents. Elle peut se servir des scores de la journée précédente (nombre d'utilisateurs pour chaque mode de transport et performance de chaque mode)  et doit renvoyer une valeur de \texttt{carFactor} qui correspondra à la nouvelle probabilité pour une personne de choisir la voiture.
\end{itemize}

Le choix de \texttt{carFactor()} est délicat et représente donc la façon de penser des utilisateurs. Cette fonction devra être perfectionnée par l'utilisateur du prototype selon ses métadonnées et sa connaissance du comportement des usagers du plateau de Saclay. Nous avons nous même implémenté un simple ratio (le moyen de transport le plus rapide est le plus choisi). On pourrait aussi imaginer une notion de coût du trajet ou de praticité qui dissuade les utilisateurs dans un sens ou dans un autre.\\

On effectue par exemple une simulation avec seulement 100 personnes par journée, sur 8 jours, sans traffic supplémentaire que ces 100 personnes. Selon notre fonction de décision, on intuite que l'absence d'embouteillages devrait rendre la voiture plus efficace et donc pousser les utilisateurs à l'adopter. On récupère les résultats en console et on vérifie ainsi bien le comportement en figure 4.\\

\begin{center}
\begin{tikzpicture}
\begin{axis}[grid=major,
xlabel={\# Journée},
ylabel={Probabilité de choix},
legend entries={Voiture, Transports}]

\addplot coordinates {(0,0.5) (1,0.82) (2,0.77) (3,0.88) (4,0.89) (5,0.73) (6,0.81) (7,0.75) (8,0.77)};
\addplot coordinates {(0,0.5) (1,0.18) (2,0.23) (3,0.12) (4,0.11) (5,0.27) (6,0.19) (7,0.25) (8,0.23)};

\end{axis}
\end{tikzpicture}

\vspace{0.5cm}
Figure 4 : Evolution des comportements sur 8 jours sans embouteillages
\end{center}

On remarque d'ailleurs qu'il y a un certain bruit dans le comportement, mais qui pourrait être diminué avec un choix de modèle plus peaufiné, pondéré sur plusieurs jours par exemple.\\


%------------------------------------------------

\pagebreak
\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion}


On aura donc développé un prototype d'application permettant l'étude des déplacements des usagers du Plateau de Saclay. Les simulations sont très modulables ce qui permet donc à l'utilisateur de personnaliser ses modélisation selon ses besoins et ses métadonnées.\\

Les simulations sont observables sous différents angles et à l'aide de différentes métriques : interface graphique, log des déplacements, compte rendu des performances sur une journée, fonction de décision des utilisateurs... Qui nous on permis de vérifier le fonctionnement du prototype et qui permettront aux utilisateurs de tirer des conclusions de leurs simulations.\\


%----------------------------------------------------------------------------------------

\end{document}