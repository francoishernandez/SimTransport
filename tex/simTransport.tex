%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RAPPORT DE CEI // TNP CONSULTANTS // ETP ADVISOR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper, 11pt]{article} % Font size (can be 10pt, 11pt or 12pt) and paper size (remove a4paper for US letter paper)

\renewcommand{\contentsname}{Table des matières}
\renewcommand{\listfigurename}{Table des figures}

\usepackage{hyperref}

\usepackage[babel=true]{csquotes}

\usepackage{standalone}

\usepackage{changepage}

\usepackage{caption}
\usepackage{subcaption}

%\usepackage[a4paper,left=2.5cm,right=2.5cm]{geometry}

\addtolength{\hoffset}{-1cm}
\addtolength{\textwidth}{2cm}
\addtolength{\topmargin}{-1.5cm}
\addtolength{\textheight}{2cm}

\usepackage{indentfirst}
%\usepackage[utf8]{inputenc}
\usepackage{pgfplots}
\usepackage{color}

\usepackage{enumerate}

\usepackage[protrusion=true,expansion=true]{microtype} % Better typography

\renewcommand{\thesection}{\Roman{section}}
\usepackage{titlesec}
%\titlespacing\section{0pt}{20pt plus 4pt minus 2pt}{-5pt plus 2pt minus 2pt}

\usepackage{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Required for accented characters
\linespread{1.05} % Change line spacing here, Palatino benefits from a slight increase by default

\makeatletter
\renewcommand\@biblabel[1]{\textbf{#1.}} % Change the square brackets for each bibliography item from '[1]' to '1.'
\renewcommand{\@listI}{\itemsep=0pt} % Reduce the space between items in the itemize and enumerate environments and the bibliography

\usepackage{titlesec}
\usepackage[T1]{fontenc}
%\titlespacing{\chapter}{0}{0*}{0*}{}
%\titlespacing{\section}{2ex}{0*}{0*}{}
\usepackage{colortbl}
\usepackage{multirow}

%\newdimen\saveskip % Un registre pour garder la valeur actuelle de \leftskip
\newdimen\chapterskip
\newdimen\sectskip
\newdimen\subsectskip
\newdimen\subsubsectskip

%\saveskip=\leftskip
\chapterskip=10pt     % Espacement pour les chapitres
\sectskip=4ex        % Pour les sections
\subsectskip=10ex    % etc.
\subsubsectskip=18ex

% Reprise de ton code ici, mais en appelant les valeurs définies plus haut

\setcounter{secnumdepth}{3} % On affiche une numérotation sur une profondeur de 3
%\setcounter{tocdepth}{3} % La table des matières va a une profondeur de 3
% Alignement des titres :
%\titlespacing{\chapter} {\chapterskip} {*0} {*0} {}
%\titlespacing{\section} {\sectskip} {*0} {*0} {}
%\titlespacing{\subsection} {\subsectskip} {*0} {*0} {}
%\titlespacing{\subsubsection} {\subsubsectskip} {*0} {*0} {}

% Et ici, on surcharge les commandes \chapter, \section, etc.,
% afin de modifier \leftskip.

\setcounter{tocdepth}{3}

\renewcommand{\thesection}{\Roman{section}}

\titleformat{\paragraph}[hang]{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}{0pt}{3.25ex plus 1ex minus .2ex}{1em}

%----------------------------------------------------------------------------------------
%	FIGURES ET IMAGES
%----------------------------------------------------------------------------------------

\usepackage{graphicx} % Required for including pictures
\usepackage{wrapfig} % Allows in-line images

\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage{pgf}
\usepackage{pgfplots}
\usetikzlibrary{arrows}
\usepackage{tkz-graph}
\usetikzlibrary{shapes.multipart}

%----------------------------------------------------------------------------------------
%	TITLE
%----------------------------------------------------------------------------------------

\renewcommand{\maketitle}{ % Customize the title - do not edit title and author name here, see the TITLE block below
\begin{flushright} % Right align
{\LARGE\@title} % Increase the font size of the title

\vspace{50pt} % Some vertical space between the title and author name

{\large\@author} % Author name
\\\@date % Date

\vspace{-20pt} % Some vertical space between the author block and abstract
\end{flushright}
}

%-----------

\title{\textbf{Introduction aux Systèmes Multi-Agents}\\ % Title
Projet : SimTransport} % Subtitle

\author{\textsc{Fran\c cois Hernandez - L\'eo Pons} % Author
\\{\textit{CentraleSup\'elec}}} % Institution

\date{\today} % Date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title section

\pagebreak
\tableofcontents

\pagebreak

%----------------------------------------------------------------------------------------
%	ABSTRACT AND KEYWORDS
%----------------------------------------------------------------------------------------

%\renewcommand{\abstractname}{Summary} % Uncomment to change the name of the abstract to something else



\vspace{30pt} % Some vertical space between the abstract and first section

%----------------------------------------------------------------------------------------
%	ESSAY BODY
%----------------------------------------------------------------------------------------

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

Un Système Multi-Agents est un système composé d'un ensemble d'agents, situés dans un certain environnement et interagissant selon certaines relations. Un agent est une entité caractérisée par le fait qu'elle est, au moins partiellement, autonome. Le fonctionnement du système est défini par le fonctionnement des agents, le système central ne fait qu'office d'environnement d'évolution et de communication des différents agents. On parle d'intelligence artificielle distribuée.\\

Ce projet a pour objectif de construire une simulation des transports sur le plateau de Saclay. Pour cela, on utilisera la plateforme Jade. La plateforme Jade est une plateforme répartie d'agents s'exécutant de manière asynchrone (chaque agent est une thread). Chaque agent définit ses actions à l'aide de comportements qu'il exécute les uns après les autres. La programmation de ces comportements se fait de manière à les "entrelacer' dans l'exécution de l'agent. Dans ces comportements, les agents peuvent envoyer et recevoir des messages, mais ils peuvent aussi déclencher d'autre comportements ou même créer d'autres agents.\\

Le but du projet est de simuler et d'étudier des politiques d'aménagement des transports à l'aide d'un simulateur multi-agent. Nous adoptons une modélisation simplifiée pour étudier quelques hypothèses et mesurer l'impact des paramètres sur la simulation.\\

Ce rapport fait le tour de notre travail mais ne va pas forcément au coeur des implémentations, celles-ci étant commentées à même le code.


%------------------------------------------------
\pagebreak
\section{Présentation générale}

Nous avons donc construit un prototype de plateforme pour simuler les déplacements des utilisateurs sur le plateau de Saclay. Cette simulation n'est pas une fin en soi, l'idée est de pouvoir simuler et donc tenter prédire le comportement de ces utilisateurs (par exemple leur propension à choisir les transports en commun) en fonction de différents paramètres (par exemple la fréquence des transports en commun, ou la fermeture d'une route). L'application doit donc pouvoir être utilisée pour estimer l'impact de paramètres réels sur le traffic.

\subsection{Fonctionnement général}

Le prototype comprend un simulateur des déplacements d'agents sur le plateau sur une journée. Les agents qui évoluent au cours de cette journée sont déterminés à l'avance, et ont un emploi du temps à suivre et un choix de mode de transport fixé : soit la voiture, soit les transports en commun et la marche. Au cours de la journée, des embouteillages peuvent se créer pour les voyageurs en voiture s'ils sont trop nombreux, ce qui les ralentit considérablement. Les performances des deux modes de transport (temps passé à voyager) sont relevées pendant toute la journée.\\

À partir de ce simulateur sont possibles deux types de déductions :
\begin{itemize}
\item Des estimations de performances du réseau : avec un pool d'utilisateurs donné, simplement mesurer les performances du réseau, et évaluer la criticité du blocage de certaines routes ou de la suppression de certaines lignes de bus.
\item Des estimations du comportement des utilisateurs : la simulation peut être effectuée sur plusieurs jours. Les agents sont les mêmes de jour en jour, mais choisissent chaque matin d'utiliser la voiture ou les transports en commun en fonction des performances des jours précédents. On peut ainsi étudier l'impact d'un changement dans le réseau sur plusieurs jours et donc l'évolution des choix des utilisateurs.
\end{itemize}


\subsection{Structure globale du code}
 
Le programme comporte les packages suivants :
\begin{itemize}
\item \texttt{Environment} : contient les différents éléments de l'environnement dans lequel se déroulera la simulation (horloge et environnement) ;
\item \texttt{Environment.Points} : contient les différents types de points ;
\item \texttt{Environment.Paths} : contient les différents types de chemins ;
\item \texttt{Graphics} : contient les différentes classes associées à la représentation graphique de la simulation ;
\item \texttt{Individuals} : contient les différentes classes et comportements liés aux individus.
\item \texttt{Util} : contient la classe permettant d'importer les points et chemins stockés au format \texttt{csv} ;
\item \texttt{mainPackage} : contient la classe agent \texttt{Starter} et son comportement \texttt{Days} qui permettent de créer l'environnement et les agents pour lancer la simulation.
\end{itemize}


\section{Objets et structure du programme}

Avant même de considérer la partie simulation multi-agents, il faut créer la structure du programme permettant de simuler le problème. La structure choisie est détaillée ci-après.

\subsection{Points}

Afin de représenter les différents points utiles à notre simulation, nous créons les classes suivantes, regroupées dans le package \texttt{Environment.Points} :
\begin{itemize}
\item \texttt{Point} : point "classique" ne représentant pas de lieu particulier, comporte des coordonnées (\texttt{x}, \texttt{y}, \texttt{z}), un \texttt{id} entier et un nom \texttt{name} ainsi que les différents getters et setters utiles ;
\item \texttt{EntryPoint} : point "source" à partir duquel les individus entreront dans la simulation, hérite de \texttt{Point} ;
\item \texttt{InterestPoint} : point "d'intérêt" auquel les individus désireront se rendre, hérite de \texttt{Point} ;
\item \texttt{PreEntryPoint} : point se trouvant avant les points d'entrée, afin d'éviter toute situation où un agent d'un certain type serait bloqué à un \texttt{EntryPoint} ne disposant pas de chemin compatible avec son type.
\end{itemize}

\subsection{Chemins}

Nous représentons aussi différents types de chemins. Pour cela, nous avons fait le choix d'un typage fort des chemins. Nous aurons un objet par type de chemin et par sens (de A vers B). Ainsi, par exemple, pour un chemin qui peut être emprunté par des piétons et des vélos, dans les deux sens, il y aura quatre objets. Les classes sont donc définies de la manière suivante dans le package \texttt{Environment.Paths} :
\begin{itemize}
\item \texttt{Path} : classe mère dont hériteront tous les chemins 'typés', comporte un point \texttt{A} source et un point \texttt{B} destination, les getters et setters associés ainsi que différentes méthodes permettant de récupérer la distance (dans l'espace et projetée sur le plan), le dénivelé et la pente ;
\item \texttt{FootPath} : chemin piéton héritant de \texttt{Path} et comportant une méthode \texttt{weight()} retournant le temps de parcours nécessaire (pour une vitesse moyenne de 5km/h, et prenant en compte la difficulté accrue pour un dénivelé positif) ;
\item \texttt{RoadPath} : chemin routier (agglomération) héritant de \texttt{Path} et comportant une méthode \texttt{weight()} retournant le temps de parcours nécessaire pour une vitesse moyenne de base de 35 km/h, la durée étant exponentiellement allongée lorsque la densité d'utilisateurs sur la voie dépasse un seuil critique de 1 utilisateur pour 10m (embouteillages) ;
\item \texttt{HighwayPath} : chemin routier (nationale) héritant de \texttt{Path} et comportant une méthode \texttt{weight()} retournant le temps de parcours nécessaire pour une vitesse moyenne de base de 90 km/h, la durée étant exponentiellement allongée lorsque la densité d'utilisateurs sur la voie dépasse un seuil critique de 2 utilisateurs pour 10m (embouteillages) ;
\item \texttt{BusPath} : chemin représentant un autobus (de vitesse moyenne 50 km/h), héritant de \texttt{Path} et comportant un temps d'attente moyen et une méthode \texttt{weight()} retournant le temps de parcours nécessaire (calculé à partir de la vitesse et du temps perdu aux arrêts) ;
\item \texttt{RerPath} : chemin représentant un RER (de vitesse moyenne 80 km/h), héritant de \texttt{Path} et comportant un temps d'attente moyen et une méthode \texttt{weight()} retournant le temps de parcours nécessaire (calculé à partir de la vitesse et du temps perdu aux arrêts) ;
\item \texttt{EntryPath} : chemin entre les \texttt{PreEntryPoint} et \texttt{EntryPoint}, de poids nul (un agent débutera, sans délai, au point d'entrée le plus proche correspondant à son type).
\end{itemize}

\subsection{Temps}

Nous avons aussi créé une classe \texttt{Time} afin de représenter le temps et de pouvoir implémenter une horloge pour notre problème. Cette classe comporte trois attributs byte \texttt{hours}, \texttt{minutes} et \texttt{seconds}, ainsi que leurs getters. Elle comporte aussi les méthodes suivantes :
\begin{itemize}
\item \texttt{incMinute(byte m)} : incrémente l'heure de \texttt{m} minutes ;
\item \texttt{incSeconds(byte s)} : incrémente l'heure de \texttt{s} secondes ;
\item \texttt{equals(Time toCompare)} : retourne un booléen vrai si \texttt{this} et \texttt{toCompare} sont égaux ;
\item \texttt{randomBegin()} : retourne une heure aléatoire de départ du point d'entrée, distribuée selon une gaussienne autour de 10h du matin, entre 2h et 20h, et les minutes sont déterminées aléatoirement ;
\item \texttt{randomEnd(Time begin)} : retourne une heure aléatoire de départ du travail, distribuée selon une gaussienne autour de 18h, comprise entre l'heure d'arrivée plus deux heures et minuit, et les minutes sont déterminées aléatoirement.
\end{itemize}

\subsection{Environnement}

Afin de représenter l'environnement global de notre simulation, nous avons créé une classe \texttt{Environment} qui sera instanciée une unique fois et contiendra les différents éléments du problème.

\paragraph{Attributs}

Cette classe contient les différents éléments de la simulation :
\begin{itemize}
\item \texttt{points} : une \texttt{ArrayList} d'objets \texttt{Point} (classe mère et sous-classes) comprenant l'ensemble des points considérés ;
\item \texttt{carPaths} : une \texttt{ArrayList} d'objets \texttt{Path} n'autorisant que les usagers en voiture (\texttt{RoadPath} et \texttt{HighwayPath}) ;
\item \texttt{publicTransportPaths} : une \texttt{ArrayList} d'objets \texttt{Path} n'autorisant que les usagers non motorisés (\texttt{FootPath}, \texttt{BikePath}, \texttt{BusPath} et \texttt{RerPath}).
\end{itemize}

\paragraph{Méthodes}

En plus des getters et setters usuels, cette classe contient également les méthodes permettant d'implémenter un algorithme de Djikstra afin de retourner le plus court chemin d'un point A à un point B sur le graphe des points de l'environnement.
\begin{itemize}
\item \texttt{initializeWeights} : retourne, à partir d'une \texttt{ArrayList<Point>} et d'une \texttt{ArrayList<Path>}, la matrice des poids minimal entre les points, c'est à dire la matrice de taille \texttt{n}x\texttt{n} avec \texttt{n} le nombre de points, contenant l'éventuel poids minimal (s'il existe un chemin) entre deux points ;
\item \texttt{initializePaths} : retourne,  à partir d'une \texttt{ArrayList<Point>} et d'une \texttt{ArrayList<Path>} et d'une matrice de poids (\texttt{double[][]}, la matrice des éventuels chemins de poids minimal entre les points ;
\item \texttt{shortestPathPointList} : implémente, à partir d'une \texttt{ArrayList<Point>}, d'une \texttt{ArrayList<Path>}, d'un point \texttt{source} et d'un point \texttt{target}, l'algorithme de Djikstra et retourne une \texttt{ArrayList<Point>} contenant les points formant le plus court chemin entre deux points ;
\item \texttt{shortestPath} : récupère la liste des chemins formant le plus court chemin, à partir des méthodes \texttt{findShortestPath} et \texttt{initializePaths} ;
\item \texttt{shortestCarPath} : retourne les chemins formant le plus court chemin pour un usager automobiliste ;
\item \texttt{shortestPublicTransportPath} : retourne les chemins formant le plus court chemin pour un usager non motorisé.

\end{itemize}


\section{Agents et comportements}

\subsection{Horloge}

Dans le package \texttt{Environment} on retrouve deux classes : \texttt{Clock} et \texttt{ClockTick}. Notre premier agent, le plus important, est en effet l'horloge. Un seul agent d'horloge est créé pour la journée, et sont rôle sera de mesurer l'heure et d'en informer les autres agents.\\

\texttt{Clock} possède un attribut \texttt{currentTime} de type \texttt{Time} décrit plus haut. Cet attribut représente l'heure de notre système. Elle est régulièrement incrémentée à l'aide du comportement \texttt{ClockTick} héritant de \texttt{TickerBehaviour} de Jade. Ce type de comportement est appelé à intervalles réguliers, l'intervalle étant défini ici à l'aide de la durée réelle \texttt{simulationTime} d'exécution souhaitée pour une journée simulée ; et de l'intervalle de temps minimal simulé \texttt{stepLength}, typiquement 15 secondes (un intervalle plus grand, de une minute par exemple, a l'inconvénient d'arrondir à une minute toutes les durées inférieures, ce qui fausse vite la simulation sur les segments courts).\\

À chaque tick d'horloge, \texttt{ClockTick} envoie aussi un message contenant l'heure du système à tous les autres agents. Le comportement s'arrête quand minuit est atteint. Un message est alors envoyé à l'agent \texttt{Starter} pour prévenir de la fin de journée.\\

\subsection{Individus}

\subsubsection{Principaux attributs}

Chaque personne est représentée par un agent \texttt{Person}. Ils possèdent chacun des attributs comme :
\begin{itemize}
\item Leur point de pré-entrée, déterminé à la construction
\item Leur emploi du temps \texttt{schedule}, déterminé à la construction et qui sera "consommé" au fur et à mesure de la journée
\item Leur localisation (point et éventuellement chemin)
\item Leur choix de mode de transport, déterminé à la construction
\item L'ID de la ligne de transport en commun qu'ils empruntent actuellement (0 sinon). Cela servira pour détecter les changements de ligne.
\end{itemize}

L'emploi du temps \texttt{schedule} consiste en une liste de rendez-vous \texttt{Appointement}, qui sont eux-mêmes de simples couples (\texttt{Point}, \texttt{Time}) correspondants à la destination et à l'heure de départ (et non d'arrivée).\\

Ces agents fonctionnent comme des machines à état, et un type énuméré \texttt{PersonState} est donc créé pour décrire ces états. Trois états sont possibles : 
\begin{itemize}
\item \texttt{in\_place} : La personne est là où elle doit se trouver, mais il reste des déplacements prévus dans son emploi du temps.
\item \texttt{moving} : La personne est en déplacement.
\item \texttt{gone} : La personne est rentrée chez elle, son emploi du temps a été entièrement exécuté, elle n'interviendra plus de la journée.
\end{itemize}

Cet état est stocké dans l'attribut \texttt{personState}. Les comportements \texttt{InPlace} et \texttt{Moving} associés sont décrits dans les parties suivantes (L'état \texttt{gone} n'a pas de comportement associé : cet état correspond à l'arrêt des différents comportements).

\subsubsection{Comportement InPlace}

Quand il est \texttt{in\_place}, l'agent attend un signal de départ à l'aide de son comportement \texttt{InPlace}. C'est un comportement déclenché à chaque réception de tick d'horloge. L'heure est comparée avec l'heure du départ du prochain \texttt{Appointement}. Si il est l'heure de partir, on enclenche le trajet en créant un nouveau comportement \texttt{Moving} associé au point de destination. Le rendez-vous est supprimé du \texttt{schedule}, \texttt{PersonState} est modifié, et le comportement \texttt{InPlace} est ensuite arrêté. \\

\subsubsection{Comportement Moving}

Quand il est \texttt{moving}, l'agent se déplace vers son point de destination à l'aide de son comportement \texttt{Moving}. Le comportement est créé avec un point de destination, conservé en attribut. Lors de son déplacement, l'agent peut se trouver dans deux états différents correspondant à des phases différentes du mouvement. On créera pour celà un type énuméré \texttt{MovingState} :
\begin{itemize}
\item \texttt{none} : La personne n'est pas dans un état de mouvement \texttt{moving}
\item \texttt{point} : La personne est à un \texttt{Point}, en attente du choix du prochain \texttt{Path}
\item \texttt{path} : La personne est en train de parcourir un \texttt{Path}
\end{itemize}

Quand il est sur un point, l'agent récupère le prochain segment à emprunter à l'aide de Djikstra. On récupère le temps nécessaire pour parcourir le segment (prenant en compte comme expliqué la côte à pied, les embouteillages en voiture, et le temps d'arrêt en transports en commun). On y ajoute l'éventuel temps d'attente moyen lors d'un changement de ligne. On stocke ce temps dans un attribut \texttt{timeNeeded} et on initialise un compteur de temps passé sur le segment \texttt{currentPathProgress} à 0. On incrémente les compteurs globaux de temps passé dans les transports. Le moving state est finalement passé à \texttt{path}.\\

Quand il est sur un segment, l'agent écoute les tick d'horloge et incrémente son compteur de temps passé sur le segment \texttt{currentPathProgress}. Quand \texttt{timeNeeded} est atteint, on change finalement l'attribut \texttt{localisation} de l'agent pour le placer sur le prochain point. Si le point atteint est la destination, on arrête le mouvement et on passe en \texttt{in\_place} si il reste des rendez-vous et en \texttt{gone} sinon. Si le point atteint n'est pas la destination, le mouvement continue et on recommence ce cycle en passant le moving state à \texttt{point}.\\

\subsubsection{Construction}

Les personnes présentent un constructeur qui permet de les construire à la main, mais nous utiliserons plutôt un constructeur \texttt{rand\_AllerRetour} qui construit une personne avec un emploi du temps simple : un aller retour depuis un point de pré-entrée vers un point d'intérêt. Les heures des trajets sont définies à l'aide de \texttt{randomBegin()} et \texttt{randomEnd()} décrite plus haut dans la section Time.\\

On se rendra vite compte que la création de trop nombreux agents peut créer des problèmes de mémoire et de CPU suivant la machine et les paramètres. Pour pouvoir constater des embouteillages plus facilement, on introduira dans le starter un paramètre \texttt{realUsersPerPerson} qui représente le nombre d'usagers réels représentés par un agent \texttt{Person}. Cette valeur interviendra dans les calculs de densité d'utilisateurs des routes.\\

\pagebreak 
\section{Interface}

\subsection{Mode Verbose}

EXPLIQUER RAPIDO LES DIFFERENTS NIVEAUX

\subsection{Interface graphique}

AJOUTER LES NOUVEAUTÉS

Afin d'avoir une représentation graphique claire des différents points, chemins, et des évènements de la simulation, nous avons choisi de définir une interface graphique à l'aide des outils \texttt{Swing}. Cela consiste en deux classes \texttt{Window} et \texttt{Panel}. \texttt{Window} hérite de la classe \texttt{JFrame} et définit les caractéristiques de la fenêtre qui contiendra le \texttt{Panel}. \texttt{Panel} hérite de la classe \texttt{JPanel} et contient les méthodes associées au dessin des représentations. La méthode \texttt{paintComponent} dessine les différents éléments dans un \texttt{bufferGraphics}, attribut d'une image. L'horloge est également affichée.\\

Afin d'avoir une simulation plus réaliste et de pouvoir mieux se représenter le problème, nous avons choisi de nous baser sur une carte réelle (Google Maps) pour définir nos points et chemins.\\

\begin{figure}[!h]
\begin{center}
\includegraphics[width=0.8\textwidth]{plateau.png}
\caption{Représentation graphique de la simulation}
\end{center}
\end{figure}

\subsection{Lancement d'une simulation}

EXPLIQUER LE LANCEMENT DANS STARTER + DAYS

%------------------------------------------------
\pagebreak

\section{Principaux paramètres de la simulation}

%------------------------------------------------
\pagebreak

\section{Simulation de différentes politiques d'aménagement}


%------------------------------------------------

%\pagebreak
%\section*{Conclusion}
%\addcontentsline{toc}{section}{Conclusion}


%----------------------------------------------------------------------------------------

\end{document}